import tkinter as tk
from tkinter import filedialog, messagebox, ttk
import cv2
import numpy as np
from PIL import Image, ImageTk, ImageDraw, ImageFont
import os
import platform
import glob

# --- å°è¯•å¯¼å…¥æ‹–æ‹½æ”¯æŒåº“ ---
try:
    from tkinterdnd2 import DND_FILES, TkinterDnD
    HAS_DND = True
except ImportError:
    HAS_DND = False
    print("æç¤º: æœªå®‰è£… tkinterdnd2 åº“ï¼Œæ‹–æ‹½åŠŸèƒ½ä¸å¯ç”¨ã€‚è¯·è¿è¡Œ pip install tkinterdnd2")

class SignatureExtractorApp:
    def __init__(self, root):
        self.root = root
        self.root.title("å…¨èƒ½ç­¾åè®¾è®¡ä¸æå–å™¨ (SVG/PNG)")
        self.root.geometry("1100x750")
        
        # æ ·å¼è®¾ç½®
        style = ttk.Style()
        style.theme_use('clam')
        
        # çŠ¶æ€å˜é‡
        self.original_cv_image = None  # å½“å‰å¤„ç†çš„OpenCVå›¾åƒ
        
        # å­˜å‚¨åŸå§‹è½®å»“æ•°æ®ï¼Œç”¨äºå¯¼å‡ºæ—¶é‡æ–°è®¡ç®—
        self.raw_contours = []
        self.raw_hierarchy = None
        
        self.processed_contours = []   # ç”¨äºé¢„è§ˆçš„ç®€åŒ–è½®å»“
        self.preview_image_tk = None   # é˜²æ­¢è¢«åƒåœ¾å›æ”¶
        self.source_image_tk = None    # å·¦ä¾§åŸå›¾é¢„è§ˆ
        self.is_text_mode = False      # æ ‡è®°å½“å‰æ˜¯å¦å¤„äºæ–‡å­—æ¨¡å¼
        
        # --- å­—ä½“ç³»ç»Ÿåˆå§‹åŒ– ---
        self.system_font_dir = self.get_system_font_dir()
        self.font_list = self.scan_fonts()
        # ä¼˜å…ˆå¯»æ‰¾è¡Œæ¥·
        default_font_file = self.find_preferred_font(["STXINGKA.TTF", "STXINGKA.GM", "SIMLI.TTF", "simkai.ttf", "msyh.ttc"])
        
        self.font_path = os.path.join(self.system_font_dir, default_font_file) if default_font_file else None
        self.loaded_font_name = default_font_file if default_font_file else "é»˜è®¤å­—ä½“"
        
        # --- å¸ƒå±€è®¾è®¡ ---
        
        # 1. é¡¶éƒ¨ï¼šå…¬å…±å‚æ•°æ§åˆ¶
        self.setup_top_controls()

        # 2. ä¸»åŒºåŸŸï¼šå·¦å³åˆ†æ 
        main_paned = ttk.PanedWindow(root, orient=tk.HORIZONTAL)
        main_paned.pack(fill=tk.BOTH, expand=True, padx=10, pady=5)
        
        # --- å·¦ä¾§ï¼šè¾“å…¥æº ---
        left_container = ttk.Frame(main_paned)
        main_paned.add(left_container, weight=1)
        
        self.notebook = ttk.Notebook(left_container)
        self.notebook.pack(fill=tk.BOTH, expand=True)
        self.notebook.bind("<<NotebookTabChanged>>", self.on_tab_change)
        
        # é€‰é¡¹å¡ 1: å›¾ç‰‡æå–æ¨¡å¼
        self.tab_image = ttk.Frame(self.notebook)
        self.notebook.add(self.tab_image, text=" ğŸ“· å›¾ç‰‡æå–æ¨¡å¼ ")
        self.setup_image_tab()
        
        # é€‰é¡¹å¡ 2: æ–‡å­—ç”Ÿæˆæ¨¡å¼
        self.tab_text = ttk.Frame(self.notebook)
        self.notebook.add(self.tab_text, text=" âœï¸ æ–‡å­—ç”Ÿæˆæ¨¡å¼ ")
        self.setup_text_tab()
        
        # --- å³ä¾§ï¼šç»“æœé¢„è§ˆ ---
        right_frame = ttk.LabelFrame(main_paned, text="ç»“æœé¢„è§ˆ (é€æ˜èƒŒæ™¯)", padding=5)
        main_paned.add(right_frame, weight=1)
        
        self.canvas_preview = tk.Canvas(right_frame, bg="white") 
        self.canvas_preview.pack(fill=tk.BOTH, expand=True)
        self.draw_checkerboard(self.canvas_preview)

        # å¦‚æœé»˜è®¤æ‰¾åˆ°äº†å­—ä½“ï¼Œä¸”åœ¨æ–‡å­—æ¨¡å¼ï¼Œåˆå§‹åŒ–ä¸€æ¬¡
        if self.font_path:
            self.notebook.select(self.tab_text)
            
        # åˆå§‹åŒ–æ‹–æ‹½ (å…¨å±€)
        if HAS_DND: self.setup_dnd()

    # --- å­—ä½“é€»è¾‘ ---
    
    def get_system_font_dir(self):
        system = platform.system()
        if system == "Windows":
            return os.path.join(os.environ.get("WINDIR", "C:\\Windows"), "Fonts")
        elif system == "Darwin":
            return "/System/Library/Fonts"
        else:
            return "/usr/share/fonts"

    def scan_fonts(self):
        fonts = []
        if os.path.exists(self.system_font_dir):
            extensions = ['*.ttf', '*.otf', '*.ttc', '*.TTF', '*.OTF', '*.TTC']
            for ext in extensions:
                found = [os.path.basename(f) for f in glob.glob(os.path.join(self.system_font_dir, ext))]
                fonts.extend(found)
        return sorted(fonts)

    def find_preferred_font(self, candidates):
        lower_fonts = [f.lower() for f in self.font_list]
        for cand in candidates:
            if cand.lower() in lower_fonts:
                idx = lower_fonts.index(cand.lower())
                return self.font_list[idx]
        return self.font_list[0] if self.font_list else None

    # --- ç•Œé¢æ„å»º ---

    def setup_top_controls(self):
        control_frame = ttk.LabelFrame(self.root, text="å¤„ç†å‚æ•° (å®æ—¶é¢„è§ˆ)", padding=10)
        control_frame.pack(side=tk.TOP, fill=tk.X, padx=10, pady=5)
        
        # ä¿å­˜æŒ‰é’®åŒº (åˆå¹¶ä¸ºä¸€ä¸ª)
        self.btn_export = ttk.Button(control_frame, text="ğŸ’¾ å¯¼å‡ºç»“æœ", command=self.export_file, state=tk.DISABLED)
        self.btn_export.pack(side=tk.RIGHT, padx=10)

        # å‚æ•°æ»‘å—åŒºåŸŸ
        slider_frame = ttk.Frame(control_frame)
        slider_frame.pack(side=tk.LEFT, fill=tk.X, expand=True)
        
        # é˜ˆå€¼
        ttk.Label(slider_frame, text="å¢¨è¿¹æµ“åº¦ (é˜ˆå€¼):").grid(row=0, column=0, sticky=tk.W)
        # ä¿®æ”¹ï¼šé»˜è®¤å€¼æ”¹ä¸º 10 (æœ€ä½)
        self.threshold_var = tk.IntVar(value=10) 
        self.slider_threshold = ttk.Scale(slider_frame, from_=0, to=255, orient=tk.HORIZONTAL, variable=self.threshold_var, command=lambda v: self.on_param_change())
        self.slider_threshold.grid(row=0, column=1, sticky=tk.EW, padx=5, ipadx=50)
        
        # å¹³æ»‘åº¦
        ttk.Label(slider_frame, text="çº¿æ¡å¹³æ»‘åº¦:").grid(row=0, column=2, sticky=tk.W, padx=(20,0))
        self.smoothness_var = tk.DoubleVar(value=0.1)
        self.slider_smooth = ttk.Scale(slider_frame, from_=0.1, to=8.0, orient=tk.HORIZONTAL, variable=self.smoothness_var, command=lambda v: self.on_param_change())
        self.slider_smooth.grid(row=0, column=3, sticky=tk.EW, padx=5, ipadx=50)

    def setup_image_tab(self):
        btn_frame = ttk.Frame(self.tab_image, padding=5)
        btn_frame.pack(fill=tk.X)
        
        btn_upload = ttk.Button(btn_frame, text="ğŸ“‚ ä¸Šä¼ å›¾ç‰‡", command=self.upload_image_dialog)
        btn_upload.pack(side=tk.LEFT)
        ttk.Label(btn_frame, text="(æ”¯æŒæ‹–æ‹½å›¾ç‰‡æ–‡ä»¶)").pack(side=tk.LEFT, padx=5)

        self.img_preview_frame = ttk.LabelFrame(self.tab_image, text="åŸå›¾é¢„è§ˆ")
        self.img_preview_frame.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
        
        self.lbl_source_img = tk.Label(self.img_preview_frame, text="è¯·æ‹–å…¥æˆ–ä¸Šä¼ å›¾ç‰‡", bg="#f0f0f0")
        self.lbl_source_img.pack(fill=tk.BOTH, expand=True)

    def setup_text_tab(self):
        container = ttk.Frame(self.tab_text, padding=10)
        container.pack(fill=tk.BOTH, expand=True)
        
        # 1. æ–‡æœ¬è¾“å…¥
        ttk.Label(container, text="è¾“å…¥ç­¾åæ–‡æœ¬ (æ”¯æŒæ‹–æ‹½å­—ä½“æ–‡ä»¶):").pack(anchor=tk.W)
        self.entry_text = ttk.Entry(container, font=("Arial", 14))
        self.entry_text.insert(0, "æ¥šæ˜Šç„¶") # é»˜è®¤æ–‡æœ¬
        self.entry_text.pack(fill=tk.X, pady=(0, 10))
        self.entry_text.bind("<KeyRelease>", lambda e: self.on_text_param_change())
        
        # 2. å­—ä½“é€‰æ‹©
        font_frame = ttk.LabelFrame(container, text="å­—ä½“é€‰æ‹©", padding=5)
        font_frame.pack(fill=tk.X, pady=5)
        
        self.font_combo = ttk.Combobox(font_frame, values=self.font_list, state="readonly", height=20)
        self.font_combo.pack(side=tk.LEFT, fill=tk.X, expand=True)
        if self.loaded_font_name in self.font_list:
            self.font_combo.set(self.loaded_font_name)
        self.font_combo.bind("<<ComboboxSelected>>", self.on_font_selected)
        
        btn_load_custom = ttk.Button(font_frame, text="ğŸ“‚ è‡ªå®šä¹‰", width=8, command=self.load_custom_font)
        btn_load_custom.pack(side=tk.RIGHT, padx=(5,0))
        
        # 3. æ–‡å­—å±æ€§æ»‘å—
        props_frame = ttk.LabelFrame(container, text="æ’ç‰ˆå±æ€§ (å®æ—¶)", padding=5)
        props_frame.pack(fill=tk.X, pady=10)
        
        # å­—å·
        ttk.Label(props_frame, text="å­—å·å¤§å°:").grid(row=0, column=0, sticky=tk.W)
        self.font_size_var = tk.IntVar(value=400) # é»˜è®¤æœ€å¤§
        scale_size = ttk.Scale(props_frame, from_=50, to=400, variable=self.font_size_var, orient=tk.HORIZONTAL, command=lambda v: self.on_text_param_change())
        scale_size.grid(row=0, column=1, sticky=tk.EW, padx=5)
        
        # å­—è·
        ttk.Label(props_frame, text="å­—ç¬¦é—´è·:").grid(row=1, column=0, sticky=tk.W)
        # ä¿®æ”¹ï¼šé»˜è®¤å€¼æ”¹ä¸º -100 (æœ€ä½)
        self.font_spacing_var = tk.IntVar(value=-100) 
        scale_spacing = ttk.Scale(props_frame, from_=-100, to=100, variable=self.font_spacing_var, orient=tk.HORIZONTAL, command=lambda v: self.on_text_param_change())
        scale_spacing.grid(row=1, column=1, sticky=tk.EW, padx=5)
        
        # å­—ä½“ç²—ç»†
        ttk.Label(props_frame, text="å­—ä½“ç²—ç»† (å·¦ä¾§ç»†-å³ä¾§ç²—):").grid(row=2, column=0, sticky=tk.W)
        self.font_weight_var = tk.DoubleVar(value=50.0)
        # è¿™é‡Œä½¿ç”¨ DoubleVar é…åˆ Scale å·²ç»æ˜¯é«˜ç²¾åº¦çš„æµ®ç‚¹æ•°ï¼Œ
        # å…³é”®æ˜¯åç«¯çš„æ¸²æŸ“é€»è¾‘éœ€è¦æ”¯æŒé«˜ç²¾åº¦ï¼Œä¸èƒ½åªæ˜¯ int() æˆªæ–­
        scale_weight = ttk.Scale(props_frame, from_=0, to=100, variable=self.font_weight_var, orient=tk.HORIZONTAL, command=lambda v: self.on_text_param_change())
        scale_weight.grid(row=2, column=1, sticky=tk.EW, padx=5)

        props_frame.columnconfigure(1, weight=1)
        
        # è¯´æ˜
        info_lbl = tk.Label(container, text="ğŸ’¡ æç¤ºï¼š\nâ€¢ å·²å¯ç”¨ 3x è¶…é‡‡æ ·æŠ€æœ¯ï¼Œå­—ä½“ç²—ç»†è°ƒèŠ‚å®ç°â€œäºšåƒç´ çº§â€ä¸æ»‘ã€‚\nâ€¢ é»˜è®¤ä¿å­˜æ ¼å¼å·²è°ƒæ•´ä¸º PNG é€æ˜å›¾ç‰‡ã€‚", 
                            justify=tk.LEFT, fg="gray", bg="#f0f0f0")
        info_lbl.pack(fill=tk.X, pady=20)
        
        # åˆå§‹è§¦å‘ä¸€æ¬¡ç”Ÿæˆ
        self.root.after(500, self.on_text_param_change)

    # --- äº‹ä»¶å¤„ç† ---

    def on_tab_change(self, event):
        current_tab = self.notebook.select()
        if current_tab == str(self.tab_text):
            self.is_text_mode = True
            self.on_text_param_change()
        else:
            self.is_text_mode = False
            if self.original_cv_image is not None:
                self.update_preview()

    def on_font_selected(self, event):
        selected_font = self.font_combo.get()
        self.font_path = os.path.join(self.system_font_dir, selected_font)
        self.on_text_param_change()

    def on_text_param_change(self):
        if not self.is_text_mode: return
        self.generate_text_signature(silent=True)

    def on_param_change(self):
        self.update_preview()

    # --- æ ¸å¿ƒé€»è¾‘ ---

    def generate_text_signature(self, silent=False):
        text = self.entry_text.get()
        if not text: return
            
        base_size = self.font_size_var.get()
        base_spacing = self.font_spacing_var.get()
        weight_percent = self.font_weight_var.get()
        
        # --- è¶…é‡‡æ ·é€»è¾‘ (Supersampling) ---
        # æˆ‘ä»¬åœ¨ 3 å€åˆ†è¾¨ç‡ä¸‹è¿›è¡Œç»˜åˆ¶å’Œç²—ç»†å¤„ç†ï¼Œç„¶åå†ç¼©å°
        # è¿™æ ·å¯ä»¥å°†ç²—ç»†çš„è°ƒæ•´é¢—ç²’åº¦æå‡ 3 å€ï¼Œè§£å†³ 1px è·³å˜çš„é—®é¢˜
        SCALE_FACTOR = 3
        
        scaled_size = base_size * SCALE_FACTOR
        scaled_spacing = base_spacing * SCALE_FACTOR
        
        stroke_width = 0
        erode_pixels = 0
        
        # é‡æ–°è®¡ç®—ç²—ç»†å‚æ•°ï¼ŒåŸºäºæ”¾å¤§åçš„å°ºå¯¸
        if weight_percent > 50:
            factor = (weight_percent - 50) / 50.0
            # ç³»æ•°å¾®è°ƒï¼Œç¡®ä¿æœ€å¤§ç²—ç»†åˆç†
            stroke_width = int(scaled_size * factor * 0.05)
        elif weight_percent < 50:
            factor = (50 - weight_percent) / 50.0
            erode_pixels = int(scaled_size * factor * 0.03)
            # åœ¨è¶…é‡‡æ ·æ¨¡å¼ä¸‹ï¼Œå³ä¾¿ç®—å‡ºæ¥æ˜¯ 1 æˆ– 2 pxï¼Œç¼©æ”¾å›å»ä¹Ÿæ˜¯äºšåƒç´ çº§åˆ«çš„å˜ç»†
        
        try:
            font = None
            if self.font_path:
                try: font = ImageFont.truetype(self.font_path, scaled_size)
                except: pass
            if font is None: font = ImageFont.load_default()
                
            total_width = 0
            max_height = 0
            dummy_draw = ImageDraw.Draw(Image.new("RGB", (1, 1)))
            char_dims = []
            
            # è®¡ç®—æ–‡å­—å°ºå¯¸
            for char in text:
                check_stroke = stroke_width if stroke_width > 0 else 0
                bbox = dummy_draw.textbbox((0, 0), char, font=font, stroke_width=check_stroke)
                w = bbox[2] - bbox[0]
                h = bbox[3] - bbox[1]
                if w <= 0: w = scaled_size // 2
                if h <= 0: h = scaled_size
                char_dims.append((w, h))
                total_width += w + scaled_spacing
                max_height = max(max_height, h)
            
            if text: total_width -= scaled_spacing
            
            padding = 50 * SCALE_FACTOR
            img_w = max(100 * SCALE_FACTOR, int(total_width + padding * 2))
            img_h = max(100 * SCALE_FACTOR, int(max_height * 2.5 + padding * 2))
            
            # 1. ç»˜åˆ¶é«˜æ¸…å¤§å›¾
            pil_image = Image.new("RGB", (img_w, img_h), "white")
            draw = ImageDraw.Draw(pil_image)
            
            current_x = padding
            baseline_y = img_h // 2 - max_height // 2
            
            for i, char in enumerate(text):
                w, h = char_dims[i]
                if stroke_width > 0:
                    draw.text((current_x, baseline_y), char, font=font, fill="black", stroke_width=stroke_width, stroke_fill="black")
                else:
                    draw.text((current_x, baseline_y), char, font=font, fill="black")
                current_x += w + scaled_spacing
            
            open_cv_image = cv2.cvtColor(np.array(pil_image), cv2.COLOR_RGB2BGR)
            
            # 2. åº”ç”¨é«˜æ¸…è…èš€ (å˜ç»†)
            if erode_pixels > 0:
                kernel = np.ones((3, 3), np.uint8)
                open_cv_image = cv2.dilate(open_cv_image, kernel, iterations=erode_pixels)

            # 3. é«˜è´¨é‡ç¼©å°å›ç›®æ ‡å°ºå¯¸ (Downsampling)
            # ä½¿ç”¨ INTER_AREA æ’å€¼ï¼Œå®ƒæ˜¯æœ€é€‚åˆç¼©å°çš„ç®—æ³•ï¼Œèƒ½ä¿ç•™ç°åº¦ç»†èŠ‚
            target_w = img_w // SCALE_FACTOR
            target_h = img_h // SCALE_FACTOR
            
            final_image = cv2.resize(open_cv_image, (target_w, target_h), interpolation=cv2.INTER_AREA)

            self.original_cv_image = final_image
            
            self.btn_export.config(state=tk.NORMAL)
            self.update_preview()
            
            if not silent: messagebox.showinfo("æˆåŠŸ", "ç”Ÿæˆå®Œæ¯•")
                
        except Exception as e:
            if not silent: messagebox.showerror("é”™è¯¯", f"ç”Ÿæˆå¤±è´¥: {e}")
    
    def process_image(self):
        """å¤„ç†å›¾åƒå¹¶ä¿ç•™åŸå§‹è½®å»“æ•°æ®"""
        if self.original_cv_image is None: return None, None
        
        gray = cv2.cvtColor(self.original_cv_image, cv2.COLOR_BGR2GRAY)
        thresh_val = self.threshold_var.get()
        _, binary = cv2.threshold(gray, thresh_val, 255, cv2.THRESH_BINARY_INV)
        kernel = np.ones((2,2), np.uint8)
        binary = cv2.morphologyEx(binary, cv2.MORPH_CLOSE, kernel)
        
        # æ ¸å¿ƒï¼šä½¿ç”¨ RETR_TREE ä¿ç•™å±‚çº§ï¼Œå¹¶å­˜å‚¨åˆ° self ä¸­ä¾›å¯¼å‡ºä½¿ç”¨
        contours, hierarchy = cv2.findContours(binary, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)
        
        self.raw_contours = contours
        self.raw_hierarchy = hierarchy
        
        return binary, contours

    def update_preview(self, event=None):
        if self.original_cv_image is None: return
        binary, contours = self.process_image()
        h, w = binary.shape
        
        epsilon_factor = self.smoothness_var.get()
        self.processed_contours = [] 
        for cnt in contours:
            area = cv2.contourArea(cnt)
            if area < 5: continue
            epsilon = epsilon_factor * 0.001 * cv2.arcLength(cnt, True)
            approx = cv2.approxPolyDP(cnt, epsilon, True)
            self.processed_contours.append(approx)
            
        display_canvas = np.ones((h, w, 3), dtype=np.uint8) * 255
        cv2.drawContours(display_canvas, self.processed_contours, -1, (0, 0, 0), -1)
        self.display_image(display_canvas, self.canvas_preview, is_preview=True)

    def display_image(self, cv_img, widget, is_preview=False):
        h, w = cv_img.shape[:2]
        display_w = widget.winfo_width()
        display_h = widget.winfo_height()
        if display_w < 50: display_w = 400
        if display_h < 50: display_h = 400
        scale = min(display_w/w, display_h/h)
        new_w, new_h = int(w*scale), int(h*scale)
        resized = cv2.resize(cv_img, (new_w, new_h), interpolation=cv2.INTER_AREA)
        rgb_img = cv2.cvtColor(resized, cv2.COLOR_BGR2RGB)
        pil_img = Image.fromarray(rgb_img)
        tk_img = ImageTk.PhotoImage(pil_img)
        
        if is_preview:
            self.preview_image_tk = tk_img
            widget.delete("img_tag")
            widget.create_image(display_w//2, display_h//2, image=tk_img, tags="img_tag")
        else:
            self.source_image_tk = tk_img
            widget.config(image=tk_img, text="")

    # --- ç»Ÿä¸€å¯¼å‡ºå…¥å£ ---
    def export_file(self):
        """ç»Ÿä¸€å¯¼å‡ºå‡½æ•°ï¼Œæ ¹æ®æ–‡ä»¶ç±»å‹åˆ†å‘"""
        if not self.processed_contours: return

        file_path = filedialog.asksaveasfilename(
            defaultextension=".png", 
            # å…³é”®ä¿®æ”¹ï¼šå°† PNG æ”¾åœ¨ç¬¬ä¸€ä¸ªï¼Œä½œä¸ºé»˜è®¤é€‰é¡¹
            filetypes=[("PNG é€æ˜å›¾ç‰‡", "*.png"), ("SVG çŸ¢é‡å›¾", "*.svg")]
        )
        if not file_path: return

        _, ext = os.path.splitext(file_path)
        ext = ext.lower()

        if ext == ".svg":
            self._write_svg(file_path)
        elif ext == ".png":
            self._write_png(file_path)
        else:
            # é»˜è®¤å…œåº•
            self._write_png(file_path + ".png")

    def _write_svg(self, filename):
        h, w = self.original_cv_image.shape[:2]
        all_path_data = []
        for cnt in self.processed_contours:
            if len(cnt) < 3: continue
            points = cnt.reshape(-1, 2)
            path_part = ["M", f"{points[0][0]} {points[0][1]}"]
            for p in points[1:]: path_part.append(f"L {p[0]} {p[1]}")
            path_part.append("Z")
            all_path_data.append(" ".join(path_part))
        full_d_string = " ".join(all_path_data)
        svg_content = [
            f'<svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="{w}" height="{h}" viewBox="0 0 {w} {h}">',
            '<!-- Generated by Python Signature Extractor -->',
            f'<path d="{full_d_string}" fill="black" stroke="none" fill-rule="evenodd" />',
            '</svg>'
        ]
        try:
            with open(filename, "w", encoding="utf-8") as f: f.write("\n".join(svg_content))
            messagebox.showinfo("æˆåŠŸ", "SVG æ–‡ä»¶å·²å¯¼å‡ºï¼")
        except Exception as e:
            messagebox.showerror("é”™è¯¯", f"{e}")

    def _write_png(self, filename):
        """ç¨³å¥çš„PNGå¯¼å‡ºï¼Œä¿®å¤ä¹‹å‰å¯èƒ½çš„ç©ºæ–‡ä»¶é—®é¢˜ + ä¸­æ–‡è·¯å¾„æ”¯æŒ"""
        if not self.raw_contours or self.raw_hierarchy is None:
            messagebox.showwarning("è­¦å‘Š", "æ²¡æœ‰å†…å®¹å¯å¯¼å‡º")
            return
            
        h, w = self.original_cv_image.shape[:2]
        
        # æ„é€ å…¨é»‘ + é€æ˜ Alpha çš„ç”»å¸ƒ
        # B, G, R é€šé“å…¨ä¸º 0 (é»‘è‰²)
        b_channel = np.zeros((h, w), dtype=np.uint8)
        g_channel = np.zeros((h, w), dtype=np.uint8)
        r_channel = np.zeros((h, w), dtype=np.uint8)
        # Alpha é€šé“åˆå§‹åŒ–ä¸º 0 (å…¨é€æ˜)
        a_channel = np.zeros((h, w), dtype=np.uint8)
        
        epsilon_factor = self.smoothness_var.get()
        hierarchy = self.raw_hierarchy[0] # è·å–å±‚çº§æ•°æ®
        
        # åˆ†ç»„ï¼šæ·±åº¦ -> è½®å»“åˆ—è¡¨
        contours_by_depth = {}
        
        # è¾…åŠ©å‡½æ•°ï¼šè®¡ç®—æ·±åº¦
        def get_depth(idx, hier):
            d = 0
            current_parent = hier[idx][3]
            while current_parent != -1:
                d += 1
                current_parent = hier[current_parent][3]
            return d

        # éå†æ‰€æœ‰åŸå§‹è½®å»“ï¼Œé‡æ–°è®¡ç®—å¹³æ»‘åçš„å½¢çŠ¶ï¼Œå¹¶æŒ‰æ·±åº¦åˆ†ç»„
        for i, cnt in enumerate(self.raw_contours):
            area = cv2.contourArea(cnt)
            if area < 5: continue # è¿‡æ»¤å™ªç‚¹
            
            # è®¡ç®—å¹³æ»‘
            epsilon = epsilon_factor * 0.001 * cv2.arcLength(cnt, True)
            approx = cv2.approxPolyDP(cnt, epsilon, True)
            
            depth = get_depth(i, hierarchy)
            if depth not in contours_by_depth:
                contours_by_depth[depth] = []
            contours_by_depth[depth].append(approx)
            
        # æŒ‰å±‚çº§ç»˜åˆ¶åˆ° Alpha é€šé“
        # å¶æ•°å±‚ (0, 2...) ç”» 255 (ä¸é€æ˜/å®ä½“)
        # å¥‡æ•°å±‚ (1, 3...) ç”» 0   (é€æ˜/æŒ–ç©º)
        max_depth = max(contours_by_depth.keys()) if contours_by_depth else 0
        
        for d in range(max_depth + 1):
            if d in contours_by_depth:
                color = 255 if d % 2 == 0 else 0
                cv2.drawContours(a_channel, contours_by_depth[d], -1, color, -1)
                
        # åˆå¹¶é€šé“
        rgba = cv2.merge((b_channel, g_channel, r_channel, a_channel))
        
        try:
            # ä¿®æ”¹ï¼šä½¿ç”¨ cv2.imencode + open å†™å…¥ï¼Œæ”¯æŒä¸­æ–‡è·¯å¾„
            is_success, im_buf_arr = cv2.imencode(".png", rgba)
            if is_success:
                with open(filename, "wb") as f:
                    f.write(im_buf_arr)
                messagebox.showinfo("æˆåŠŸ", "PNG æ–‡ä»¶å·²å¯¼å‡ºï¼\n(èƒŒæ™¯é€æ˜ï¼Œå­”æ´å·²å¤„ç†)")
            else:
                raise Exception("å›¾åƒç¼–ç å¤±è´¥")
        except Exception as e:
            messagebox.showerror("é”™è¯¯", f"PNG å¯¼å‡ºå¤±è´¥: {e}")

    # --- DND ---
    def setup_dnd(self):
        try:
            self.tab_text.drop_target_register(DND_FILES)
            self.tab_text.dnd_bind('<<Drop>>', self.handle_drop)
            self.tab_image.drop_target_register(DND_FILES)
            self.tab_image.dnd_bind('<<Drop>>', self.handle_drop)
            self.lbl_source_img.drop_target_register(DND_FILES)
            self.lbl_source_img.dnd_bind('<<Drop>>', self.handle_drop)
            self.entry_text.drop_target_register(DND_FILES)
            self.entry_text.dnd_bind('<<Drop>>', self.handle_drop)
        except Exception: pass

    def handle_drop(self, event):
        file_path = event.data
        if not file_path: return
        if file_path.startswith('{') and file_path.endswith('}'): file_path = file_path[1:-1]
        elif ' ' in file_path and not os.path.exists(file_path):
            parts = file_path.split('} {')
            if parts: file_path = parts[0].strip('{}')
            
        _, ext = os.path.splitext(file_path)
        ext = ext.lower()
        
        if ext in ['.jpg', '.jpeg', '.png', '.bmp']:
            self.notebook.select(self.tab_image)
            self.load_image_from_file(file_path)
        elif ext in ['.ttf', '.otf', '.ttc']:
            self.notebook.select(self.tab_text)
            self.font_path = file_path
            self.font_combo.set(os.path.basename(file_path))
            self.on_text_param_change()
        else:
            messagebox.showwarning("æ ¼å¼ä¸æ”¯æŒ", f"ä¸æ”¯æŒçš„æ–‡ä»¶æ ¼å¼: {ext}\nä»…æ”¯æŒå›¾ç‰‡(.jpg/.png)æˆ–å­—ä½“(.ttf/.otf)")

    def upload_image_dialog(self):
        file_path = filedialog.askopenfilename()
        if file_path:
            valid_exts = {'.jpg', '.jpeg', '.png', '.bmp'}
            _, ext = os.path.splitext(file_path)
            if ext.lower() not in valid_exts:
                messagebox.showerror("æ ¼å¼ä¸æ”¯æŒ", f"æ‚¨é€‰æ‹©çš„æ–‡ä»¶æ ¼å¼ ({ext}) ä¸å—æ”¯æŒã€‚\nè¯·é€‰æ‹©å›¾ç‰‡æ–‡ä»¶ (JPG/PNG/BMP)ã€‚")
                return
            self.load_image_from_file(file_path)

    def load_image_from_file(self, file_path):
        try:
            self.original_cv_image = cv2.imdecode(np.fromfile(file_path, dtype=np.uint8), cv2.IMREAD_COLOR)
            if self.original_cv_image is None: raise Exception("è§£ç å¤±è´¥")
            self.display_image(self.original_cv_image, self.lbl_source_img, is_preview=False)
            self.btn_export.config(state=tk.NORMAL)
            self.update_preview()
        except Exception as e: messagebox.showerror("é”™è¯¯", f"æ— æ³•åŠ è½½å›¾ç‰‡: {e}")

    def draw_checkerboard(self, canvas):
        canvas.update()
        w, h = 2000, 2000
        size = 20
        for y in range(0, h, size):
            for x in range(0, w, size):
                if (x // size + y // size) % 2 == 0:
                    canvas.create_rectangle(x, y, x+size, y+size, fill="#f0f0f0", outline="")
    
    def load_custom_font(self):
        font_path = filedialog.askopenfilename()
        if font_path:
            valid_exts = {'.ttf', '.otf', '.ttc'}
            _, ext = os.path.splitext(font_path)
            if ext.lower() not in valid_exts:
                messagebox.showerror("æ ¼å¼ä¸æ”¯æŒ", f"æ‚¨é€‰æ‹©çš„æ–‡ä»¶æ ¼å¼ ({ext}) ä¸å—æ”¯æŒã€‚\nè¯·é€‰æ‹©å­—ä½“æ–‡ä»¶ (TTF/OTF/TTC)ã€‚")
                return

            self.font_path = font_path
            self.font_combo.set(os.path.basename(font_path))
            self.on_text_param_change()

if __name__ == "__main__":
    if HAS_DND: root = TkinterDnD.Tk()
    else: root = tk.Tk()
    try:
        from ctypes import windll
        windll.shcore.SetProcessDpiAwareness(1)
    except: pass
    app = SignatureExtractorApp(root)
    root.mainloop()